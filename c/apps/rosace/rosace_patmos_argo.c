#include <stdlib.h>
#include <stdint.h>
#include <inttypes.h>
#include <math.h> //just for fabs
#include <machine/patmos.h>
#include <machine/spm.h>
#include <machine/rtc.h>
#include <pthread.h>
#include "udp.h"
#include "onera/assemblage_includes.h"
/*
 * The following include file is generated by the Prelude compiler
 * Theoretically we should include main node specific include
 * i.e. assemblage_vX.h but we know that every main node
 * assemblage, assemblage_v2, assemblage_v3, etc... share the
 * very same data type.
 */
#include "onera/assemblage.h"
#include "helpers/printf.h"
#include "helpers/pthread_barrier.h"
#include "schedules/rosace_argo_tasks_schedule.h"
#include "libmp/mp.h"

/* 
 * Defines
 */

#define MIN(a,b) (((a)<(b))?(a):(b))
#define MAX(a,b) (((a)>(b))?(a):(b))

#define LEDS *((volatile _SPM unsigned int *) (PATMOS_IO_LED))   
#define KEYS *((volatile _SPM unsigned int *) (PATMOS_IO_KEYS))
#define GPIO *((volatile _SPM unsigned int *) (PATMOS_IO_GPIO))
#define SEGDISP *((volatile _SPM unsigned int *) (PATMOS_IO_SEGDISP))
#define DEADLINE *((volatile _SPM unsigned int *) (PATMOS_IO_DEADLINE))

#define INTERNOC_MAX_PAYLOAD_SIZE 148 * sizeof(char)  //should be byte addressable (i.e. SIZE mod 8 == 0)
#define INTERNOC_PACKET_SIZE(data_len) sizeof(iphead_t) + sizeof(udphead_t) + data_len
#define INTERNOC_MAX_PACKET_SIZE INTERNOC_PACKET_SIZE(INTERNOC_MAX_PAYLOAD_SIZE)

#define MP_CHAN_NUM_BUF 1
#define MP_CHAN_BUF_SIZE INTERNOC_MAX_PACKET_SIZE

#define MP_TIMEOUT 100 //us

#define STEP_TIME_SCALE 80  //ms
#define MAX_STEP_SIM (600000 / STEP_TIME_SCALE)
#define ALT_COMMAND_STEPSIM (50000 / STEP_TIME_SCALE)

#define schedtime_t uint64_t

const int NOC_MASTER = 0;

/*
 * Types
 */

typedef struct
{
	unsigned short id;
	schedtime_t period;
	unsigned long release_inst;
	unsigned long nr_releases;
	schedtime_t last_time;
	schedtime_t delta_sum;
  schedtime_t exec_time;
	unsigned long exec_count;
	schedtime_t release_times[5];
} MinimalTTTask;

typedef struct {
  qpd_t *chanRx;
  qpd_t *chanTx;
} core_link_t;

typedef struct{
  unsigned char gateway_ip[4];
  unsigned char core_ip[4];
  unsigned char dest_ip[4];
  unsigned char src_ip[4];
  unsigned int vlinks_num;
  core_link_t vlinks[1];
  unsigned int sent_message_count;
  unsigned int received_message_count;
  unsigned int missed_message_count;
  MinimalTTTask task_sched[NUM_OF_TASKS]; 
} NoCCoreParams;

typedef struct {
  REAL_TYPE delta_e;
  REAL_TYPE T;
  struct aircraft_dynamics_outs_t outputs;
} aircraft_thread_result_t;

typedef struct {
  REAL_TYPE h_meas;
  REAL_TYPE Vz_meas;
  REAL_TYPE q_meas;
  REAL_TYPE Va_meas;
  REAL_TYPE az_meas;
} filter_thread_result_t;

typedef struct {
  REAL_TYPE Vz_c;
  REAL_TYPE delta_th_c;
  REAL_TYPE delta_e_c;
} control_thread_result_t;

/* 
 * Flags
 */
static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
static pthread_barrier_t cycle_start_b;
static uint64_t step_simu;
static uint8_t first_step = 1;
static uint8_t last_step = 0;
static uint8_t enable_communication = 0;
static uint8_t enable_control = 0;

/*
 * Functions
 */

void printSegmentInt(unsigned number) 
{
    *(&SEGDISP+0) = number & 0xF;
    *(&SEGDISP+1) = (number >> 4) & 0xF;
    *(&SEGDISP+2) = (number >> 8) & 0xF;
    *(&SEGDISP+3) = (number >> 12) & 0xF;
    *(&SEGDISP+4) = (number >> 16) & 0xF;
    *(&SEGDISP+5) = (number >> 20) & 0xF;
    *(&SEGDISP+6) = (number >> 24) & 0xF;
    *(&SEGDISP+7) = (number >> 28) & 0xF;
}

int initialize_local_schedule(int mapped_core, _SPM NoCCoreParams *core_config)
{
  core_config->gateway_ip[0] = 192;
  core_config->gateway_ip[1] = 168;
  core_config->gateway_ip[2] = 1;
  core_config->gateway_ip[3] = NOC_MASTER;
  core_config->core_ip[0] = 192;
  core_config->core_ip[1] = 168;
  core_config->core_ip[2] = 1;
  core_config->core_ip[3] = get_cpuid();
  core_config->dest_ip[0] = 192;
  core_config->dest_ip[1] = 168;
  core_config->dest_ip[2] = 1;
  core_config->dest_ip[3] = (get_cpuid() % MAPPED_CORE_COUNT)+1;
  core_config->src_ip[0] = 192;
  core_config->src_ip[1] = 168;
  core_config->src_ip[2] = 1;
  core_config->src_ip[3] = (get_cpuid() - 1 == 0) ? 3 : get_cpuid()-1;
  int i=0;
  for(int j=0; j < NUM_OF_TASKS; j++)
  {
    if(mapped_core == tasks_coreids[j])
    {
      unsigned mapped_task = j;
      core_config->task_sched[i].id = mapped_task;
      core_config->task_sched[i].period = (schedtime_t) tasks_periods[mapped_task];
      core_config->task_sched[i].release_inst = 0;
      core_config->task_sched[i].nr_releases = tasks_insts_counts[mapped_task];
      core_config->task_sched[i].last_time = 0;
      core_config->task_sched[i].delta_sum = 0;
      core_config->task_sched[i].exec_count = 0;
      core_config->task_sched[i].exec_time = 0;
      for(int k=0; k < tasks_insts_counts[mapped_task]; k++)
      {
        core_config->task_sched[i].release_times[k] = tasks_schedules[mapped_task][k];
      }
      i++;
    }
  }

  pthread_mutex_lock(&lock);
  printf("\nCore #%d started thread with core_config \n", get_cpuid());
  printf("{\n");
  printf("  Core IP: %d.%d.%d.%d\n", core_config->core_ip[0], core_config->core_ip[1], core_config->core_ip[2], core_config->core_ip[3]);
  printf("  Dest IP: %d.%d.%d.%d\n", core_config->dest_ip[0], core_config->dest_ip[1], core_config->dest_ip[2], core_config->dest_ip[3]);
  printf("  Sorc IP: %d.%d.%d.%d\n", core_config->src_ip[0], core_config->src_ip[1], core_config->src_ip[2], core_config->src_ip[3]);
  printf("  Init Tasks[%d]\n", tasks_per_cores[mapped_core]);
  printf("  {\n");
  for(int i=0; i < tasks_per_cores[mapped_core]; i++)
  {
    printf("    %20s {T = %llu μs, RLS[%lu] = (", tasks_names[core_config->task_sched[i].id], core_config->task_sched[i].period, core_config->task_sched[i].nr_releases);
    for(int k=0; k < core_config->task_sched[i].nr_releases; k++)
    {
      printf("%llu, ", core_config->task_sched[i].release_times[k]);
    }
    printf(")}\n");
  }
  printf("  }\n");
  printf("}\n");
  pthread_mutex_unlock(&lock);

  // Initialize Argo MPI
  core_config->vlinks_num = 1;
  unsigned rxChannId = (get_cpuid() - 1 == 0) ? 3 : get_cpuid()-1;
  unsigned txChannId = get_cpuid();
  core_config->vlinks[0].chanRx = mp_create_qport(rxChannId, SINK, MP_CHAN_BUF_SIZE, MP_CHAN_NUM_BUF);
  core_config->vlinks[0].chanTx = mp_create_qport(txChannId, SOURCE, MP_CHAN_BUF_SIZE, MP_CHAN_NUM_BUF);
  pthread_mutex_lock(&lock);
  printf("Core #%d created channel from RX %d and to TX %d \n", get_cpuid(), rxChannId, txChannId);
  pthread_mutex_unlock(&lock);
  mp_init_ports();

  return 1;
}

void print_task_log_stats(int mapped_core, _SPM NoCCoreParams *core_config)
{
	printf("Core %d Task log:\n", get_cpuid());
  printf("Total sent messages: %d\n", core_config->sent_message_count);
  printf("Total received messages: %d (missed = %d)\n", core_config->received_message_count, core_config->missed_message_count);
	for(int task=0; task < tasks_per_cores[mapped_core]; task++)
  {
		float avgDelta = (float) core_config->task_sched[task].delta_sum/ (float) core_config->task_sched[task].exec_count;
		printf("--task[%20s] max. et = %llu μs, avg. dt = %5.3f μs, avg. jitter = %5.3f μs from a total of %lu executions\n", 
          tasks_names[core_config->task_sched[task].id], core_config->task_sched[task].exec_time, avgDelta, fabs(core_config->task_sched[task].period - avgDelta), core_config->task_sched[task].exec_count);
	}
	printf("---------------------------------------------------------------------------\n");
} 

int internoc_ip_to_corelinkid(_SPM core_link_t *vlinks, int vlinks_num, _SPM unsigned char *gateway_ip, _SPM unsigned char *ip_addr)
{
  if(ip_addr[2] == gateway_ip[2])
  {
    for(unsigned i = 0; i < vlinks_num; i++)
    {
      if(vlinks[i].chanTx->remote == ip_addr[3]){
        return i;
      }
    }
  } else {
    for(unsigned i = 0; i < vlinks_num; i++)
    {
      if(vlinks[i].chanTx->remote == NOC_MASTER){
        return i;
      }
    }
  }
  return -1;
}

qpd_t * internoc_get_txbuffer(_SPM core_link_t *vlinks, int vlinks_num, _SPM unsigned char *gateway_ip, _SPM unsigned char *dst_ip)
{
  int index = internoc_ip_to_corelinkid(vlinks, vlinks_num, gateway_ip, dst_ip);
  return index >= 0 ? vlinks[index].chanTx : NULL;
}

qpd_t * internoc_get_rxbuffer(_SPM core_link_t *vlinks, int vlinks_num, _SPM unsigned char *gateway_ip, _SPM unsigned char *src_ip)
{
  int index = internoc_ip_to_corelinkid(vlinks, vlinks_num, gateway_ip, src_ip);
  return index >= 0 ? vlinks[index].chanRx : NULL;
}

int logging_fun(_SPM struct aircraft_dynamics_outs_t *outputs)
{
  if(first_step)
  {
    printf("\nT,Va,az,q,Vz,h\n");
    first_step = 0;
  }

  // NOTE: copy over the local_message to main memory for the printf to work.
  struct aircraft_dynamics_outs_t _print_payload;
  _print_payload.Va = outputs->Va;
  _print_payload.az = outputs->az;
  _print_payload.q  = outputs->q;
  _print_payload.Vz = outputs->Vz;
  _print_payload.h  = outputs->h;

  printf("%3.3f,%5.3f,%5.3f,%5.4f,%5.3f,%5.3f\n", 
  (step_simu * STEP_TIME_SCALE)/1000.0f, 
  _print_payload.Va, 
  _print_payload.az, 
  _print_payload.q, 
  _print_payload.Vz, 
  _print_payload.h);

  step_simu += 1;
  if(step_simu >= MAX_STEP_SIM) {
    last_step = 1;
  }
  return 1;
}

typedef struct {
  NoCCoreParams core_config;
  int debut;
  control_thread_result_t input;
  aircraft_thread_result_t results;
  struct aircraft_dynamics_prive_vars_t dynamics;
} aircraft_local_vars_t;

void *aircraft_thread(void *args)
{
  // Local variables
  _SPM aircraft_local_vars_t *local_spm = (_SPM aircraft_local_vars_t *) 0x0;
  qpd_t* tx_packet_channel;
  qpd_t* rx_packet_channel;

  // Initialize Local Schedule
  initialize_local_schedule(get_cpuid()-1, &local_spm->core_config);

  // Executive
  uint64_t step = 0;
  uint8_t finish = 0;
  local_spm->debut = 1;
  pthread_barrier_wait(&cycle_start_b);
  schedtime_t start_time = get_cpu_usecs();
	while(step < MAX_STEP_SIM && !finish)
  {
    register schedtime_t current_time = get_cpu_usecs() - start_time;
    for(unsigned task=0; task < tasks_per_cores[get_cpuid()-1]; task++)
    {
      if(current_time >= local_spm->core_config.task_sched[task].release_times[local_spm->core_config.task_sched[task].release_inst])
      {
        schedtime_t t_act = get_cpu_usecs();
        switch (local_spm->core_config.task_sched[task].id)
        {
        case ENGINE_ID:
          local_spm->results.T = engine(local_spm->input.delta_th_c);
          break;
        case ELEVATOR_ID:
          local_spm->results.delta_e = elevator(local_spm->input.delta_e_c);
          break;
        case AIRCRAFT_DYN_ID:
          aircraft_dynamics_prive(&local_spm->debut, &local_spm->dynamics, &local_spm->results.delta_e, &local_spm->results.T, &local_spm->results.outputs);
          break;
        case VL_AIR2FILTER_SEND_ID:
          // Build the message on the proper buffer
          tx_packet_channel = local_spm->core_config.vlinks[0].chanTx;
          _SPM struct aircraft_dynamics_outs_t *packet_ptr = (_SPM struct aircraft_dynamics_outs_t *) tx_packet_channel->write_buf;
          packet_ptr->Va = local_spm->results.outputs.Va;
          packet_ptr->az = local_spm->results.outputs.az;
          packet_ptr->q = local_spm->results.outputs.q;
          packet_ptr->Vz = local_spm->results.outputs.Vz;
          packet_ptr->h = local_spm->results.outputs.h;
          // Send the message
          mp_send(tx_packet_channel, MP_TIMEOUT);
          local_spm->core_config.sent_message_count++;
          break;
        case VL_CTRL2AIR_RECV_ID:
          // Build the message on the proper buffer
          rx_packet_channel = local_spm->core_config.vlinks[0].chanRx;
          if(mp_recv(rx_packet_channel, MP_TIMEOUT))
          {
            _SPM control_thread_result_t *packet_ptr = (_SPM control_thread_result_t *) rx_packet_channel->read_buf;
            local_spm->input.Vz_c = packet_ptr->Vz_c;
            local_spm->input.delta_th_c = packet_ptr->delta_th_c;
            local_spm->input.delta_e_c = packet_ptr->delta_e_c;
            mp_ack(rx_packet_channel, MP_TIMEOUT);
            local_spm->core_config.received_message_count++;
          }
          else
          {
            local_spm->core_config.missed_message_count++;
          }
          break;
        }
        local_spm->core_config.task_sched[task].release_times[local_spm->core_config.task_sched[task].release_inst] += cores_hyperperiods[get_cpuid()-1];
        local_spm->core_config.task_sched[task].release_inst = (local_spm->core_config.task_sched[task].release_inst + 1) % local_spm->core_config.task_sched[task].nr_releases;
        local_spm->core_config.task_sched[task].delta_sum += local_spm->core_config.task_sched[task].last_time == 0 ? 0 : (current_time - local_spm->core_config.task_sched[task].last_time);
        local_spm->core_config.task_sched[task].last_time = current_time;
        local_spm->core_config.task_sched[task].exec_count++;
        register schedtime_t act_delta = (get_cpu_usecs() - t_act);
        local_spm->core_config.task_sched[task].exec_time = local_spm->core_config.task_sched[task].exec_time < act_delta
                                                          ? act_delta : local_spm->core_config.task_sched[task].exec_time;
      }
    }
    pthread_mutex_lock(&lock);
    step = step_simu;
    finish = last_step;
    pthread_mutex_unlock(&lock);
	}

  pthread_mutex_lock(&lock);
  print_task_log_stats(get_cpuid()-1, &local_spm->core_config);
  pthread_mutex_unlock(&lock);

  return NULL;
} 

typedef struct {
  NoCCoreParams core_config;
  struct aircraft_dynamics_outs_t input;
  filter_thread_result_t results;
} filter_local_vars_t;

void *filter_thread(void *args)
{
  // Local variables
  _SPM filter_local_vars_t *local_spm = (_SPM filter_local_vars_t *) 0x0;

  qpd_t* tx_packet_channel;
  qpd_t* rx_packet_channel;

  // Initialize Local Schedule
  initialize_local_schedule(get_cpuid()-1, &local_spm->core_config);

  // Executive
  uint64_t step = 0;
  uint8_t finish = 0;
  pthread_barrier_wait(&cycle_start_b);
  schedtime_t start_time = get_cpu_usecs();
	while(step < MAX_STEP_SIM && !finish)
  {
    register schedtime_t current_time = get_cpu_usecs() - start_time;
    for(unsigned task=0; task < tasks_per_cores[get_cpuid()-1]; task++)
    {
      if(current_time >= local_spm->core_config.task_sched[task].release_times[local_spm->core_config.task_sched[task].release_inst])
      {
        schedtime_t t_act = get_cpu_usecs();
        switch (local_spm->core_config.task_sched[task].id)
        {
        case LOGGING_ID:
          pthread_mutex_lock(&lock);
          logging_fun(&local_spm->input);
          pthread_mutex_unlock(&lock);
          break;
        case H_FILTER_ID:
          local_spm->results.h_meas  = h_filter_25(local_spm->input.h);
          break;
        case VZ_FILTER_ID:
          local_spm->results.Vz_meas = Vz_filter_25(local_spm->input.Vz);
          break;
        case Q_FILTER_ID:
          local_spm->results.q_meas  = q_filter_25(local_spm->input.q);
          break;
        case VA_FILTER_ID:
          local_spm->results.Va_meas = Va_filter_25(local_spm->input.Va);
          break;
        case AZ_FILTER_ID:
          local_spm->results.az_meas = az_filter_25(local_spm->input.az);
          break;
        case VL_FILTER2CTRL_SEND_ID:
          // Build the message on the proper buffer
          tx_packet_channel = local_spm->core_config.vlinks[0].chanTx;
          _SPM filter_thread_result_t *packet_ptr = (_SPM filter_thread_result_t *) tx_packet_channel->write_buf;
          packet_ptr->h_meas = local_spm->results.h_meas;
          packet_ptr->Vz_meas = local_spm->results.Vz_meas;
          packet_ptr->q_meas = local_spm->results.q_meas;
          packet_ptr->Va_meas = local_spm->results.Va_meas;
          packet_ptr->az_meas = local_spm->results.az_meas;
          // Send the message
          mp_send(tx_packet_channel, MP_TIMEOUT);
            local_spm->core_config.sent_message_count++;
          break;
        case VL_AIR2FILTER_RECV_ID:
          // Build the message on the proper buffer
          rx_packet_channel = local_spm->core_config.vlinks[0].chanRx;
          if(mp_recv(rx_packet_channel, MP_TIMEOUT))
          {
            _SPM struct aircraft_dynamics_outs_t *packet_ptr = (_SPM struct aircraft_dynamics_outs_t *) rx_packet_channel->read_buf;
            local_spm->input.Va = packet_ptr->Va;
            local_spm->input.az = packet_ptr->az;
            local_spm->input.q = packet_ptr->q;
            local_spm->input.Vz = packet_ptr->Vz;
            local_spm->input.h = packet_ptr->h;
            mp_ack(rx_packet_channel, MP_TIMEOUT);
            local_spm->core_config.received_message_count++;
          }
          else
          {
            local_spm->core_config.missed_message_count++;
          }
          break;
        }
        local_spm->core_config.task_sched[task].release_times[local_spm->core_config.task_sched[task].release_inst] += cores_hyperperiods[get_cpuid()-1];
        local_spm->core_config.task_sched[task].release_inst = (local_spm->core_config.task_sched[task].release_inst + 1) % local_spm->core_config.task_sched[task].nr_releases;
        local_spm->core_config.task_sched[task].delta_sum += local_spm->core_config.task_sched[task].last_time == 0 ? 0 : (current_time - local_spm->core_config.task_sched[task].last_time);
        local_spm->core_config.task_sched[task].last_time = current_time;
        local_spm->core_config.task_sched[task].exec_count++;
        register schedtime_t act_delta = (get_cpu_usecs() - t_act);
        local_spm->core_config.task_sched[task].exec_time = local_spm->core_config.task_sched[task].exec_time < act_delta
                                                          ? act_delta : local_spm->core_config.task_sched[task].exec_time;
      }
    }
    pthread_mutex_lock(&lock);
    step = step_simu;
    finish = last_step;
    pthread_mutex_unlock(&lock);
	}

  pthread_mutex_lock(&lock);
  print_task_log_stats(get_cpuid()-1, &local_spm->core_config);
  pthread_mutex_unlock(&lock);

  return NULL;
}

typedef struct {
  NoCCoreParams core_config;
  REAL_TYPE h_c;
  REAL_TYPE Va_c;
  filter_thread_result_t input;
  control_thread_result_t results;
} control_local_vars_t;

void *control_thread(void *args)
{
  // Local variables
  _SPM control_local_vars_t *local_spm = (_SPM control_local_vars_t *) 0x0;
  qpd_t* tx_packet_channel;
  qpd_t* rx_packet_channel;

  // Initialize Local Schedule
  initialize_local_schedule(get_cpuid()-1, &local_spm->core_config);
  local_spm->results.Vz_c = -2.5;
  local_spm->Va_c = 0.0;
  local_spm->h_c = 10000.0;

  // Executive
  uint64_t step = 0;
  uint8_t finish = 0;
  pthread_barrier_wait(&cycle_start_b);
  schedtime_t start_time = get_cpu_usecs();
	while(step < MAX_STEP_SIM && !finish)
  {
    register schedtime_t current_time = get_cpu_usecs() - start_time;
    for(unsigned task=0; task < tasks_per_cores[get_cpuid()-1]; task++)
    {
      if(current_time >= local_spm->core_config.task_sched[task].release_times[local_spm->core_config.task_sched[task].release_inst])
      {
        schedtime_t t_act = get_cpu_usecs();
        switch (local_spm->core_config.task_sched[task].id)
        {
        case ALTI_HOLD_ID:
          local_spm->results.Vz_c = altitude_hold_3(local_spm->input.h_meas, local_spm->h_c, local_spm->results.Vz_c);
          break;
        case VZ_CONTROL_ID:
          local_spm->results.delta_e_c = Vz_control_3(local_spm->input.Vz_meas, local_spm->results.Vz_c, local_spm->input.q_meas, local_spm->input.az_meas);
          break;
        case VA_CONTROL_ID:
          local_spm->results.delta_th_c = Va_control_3(local_spm->input.Va_meas, local_spm->input.Vz_meas, local_spm->input.q_meas, local_spm->Va_c);
          break;
        case VL_CTRL2AIR_SEND_ID:
          // Build the message on the proper buffer
          tx_packet_channel = local_spm->core_config.vlinks[0].chanTx;
          _SPM control_thread_result_t *packet_ptr = (_SPM control_thread_result_t *) tx_packet_channel->write_buf;
          packet_ptr->Vz_c = local_spm->results.Vz_c;
          packet_ptr->delta_e_c = local_spm->results.delta_e_c;
          packet_ptr->delta_th_c = local_spm->results.delta_th_c;
          // Send the message
          mp_send(tx_packet_channel, MP_TIMEOUT);
          local_spm->core_config.sent_message_count++;
          break;
        case VL_FILTER2CTRL_RECV_ID:
          // Build the message on the proper buffer
          rx_packet_channel = local_spm->core_config.vlinks[0].chanRx;
          if(mp_recv(rx_packet_channel, MP_TIMEOUT))
          {
            _SPM filter_thread_result_t *packet_ptr = (_SPM filter_thread_result_t *) rx_packet_channel->read_buf;
            local_spm->input.h_meas  = packet_ptr->h_meas;
            local_spm->input.Vz_meas = packet_ptr->Vz_meas;
            local_spm->input.q_meas  = packet_ptr->q_meas;
            local_spm->input.Va_meas = packet_ptr->Va_meas;
            local_spm->input.az_meas = packet_ptr->az_meas;
            mp_ack(rx_packet_channel, MP_TIMEOUT);
            local_spm->core_config.received_message_count++;
          }
          else
          {
            local_spm->core_config.missed_message_count++;
          }
          break;
        }
        local_spm->core_config.task_sched[task].release_times[local_spm->core_config.task_sched[task].release_inst] += cores_hyperperiods[get_cpuid()-1];
        local_spm->core_config.task_sched[task].release_inst = (local_spm->core_config.task_sched[task].release_inst + 1) % local_spm->core_config.task_sched[task].nr_releases;
        local_spm->core_config.task_sched[task].delta_sum += local_spm->core_config.task_sched[task].last_time == 0 ? 0 : (current_time - local_spm->core_config.task_sched[task].last_time);
        local_spm->core_config.task_sched[task].last_time = current_time;
        local_spm->core_config.task_sched[task].exec_count++;
        register schedtime_t act_delta = (get_cpu_usecs() - t_act);
        local_spm->core_config.task_sched[task].exec_time = local_spm->core_config.task_sched[task].exec_time < act_delta
                                                          ? act_delta : local_spm->core_config.task_sched[task].exec_time;
      }
    }
    if(step >= ALT_COMMAND_STEPSIM)
    {
      local_spm->h_c = 11000.0;  //Command the step climb scenario
    }
    else
    {
      local_spm->h_c = 10000.0;
    }
    pthread_mutex_lock(&lock);
    step = step_simu;
    finish = last_step;
    pthread_mutex_unlock(&lock);
	}

  pthread_mutex_lock(&lock);
  print_task_log_stats(get_cpuid()-1, &local_spm->core_config);
  pthread_mutex_unlock(&lock);

  return NULL;
}

int main()
{ 
  pthread_t tid[MAPPED_CORE_COUNT];
  pthread_barrier_init(&cycle_start_b, NULL, MAPPED_CORE_COUNT);

  LED = 0x100;
  printf("\n\nInterNoC is up n' running with #%d cores and #%d tasks using #%d cores!\n", get_cpucnt(), NUM_OF_TASKS, MAPPED_CORE_COUNT);
  printSegmentInt(0xABADBABE);
  LED = 0x00;

  if(NOC_CORES-1 >= MAPPED_CORE_COUNT)
  {  
    // Create threaded tasks
    if (pthread_create(&tid[1], NULL ,&aircraft_thread, NULL) != 0) 
    {
      printf("\nError: Compute thread %d not created\n", 1);
      return 1;
    }
    LED = 0x1;
    if (pthread_create(&tid[2], NULL ,&filter_thread, NULL) != 0) 
    {
      printf("\nError: Compute thread %d not created\n", 2);
      return 1;
    }
    LED = 0x2;
    if (pthread_create(&tid[3], NULL ,&control_thread, NULL) != 0) 
    {
      printf("\nError: Compute thread %d not created\n", 3);
      return 1;
    }
    LED = 0x4;

    uint64_t step = 0;
    do
    {
      pthread_mutex_lock(&lock);
      step = step_simu;
      pthread_mutex_unlock(&lock);
      printSegmentInt(step);
      if(KEYS == 0xE) {
        pthread_mutex_lock(&lock);
        last_step = 1;
        pthread_mutex_unlock(&lock);
      }
    } while(step < MAX_STEP_SIM && !last_step);

    // Join threaded tasks
    for(unsigned core_id = 1; core_id <= MAPPED_CORE_COUNT; core_id++) {
      void * dummy;
      int retval = pthread_join(tid[core_id-1], &dummy);
      if(retval != 0)
      {
        printf("Unable to join thread %d, error code %d\n", core_id, retval);
        return retval;
      }
      LED -= core_id;
    }
  }
  else
  {
    printf("\nError: Number of tasks (#%d) exceeds number of cores (#%d)\n", MAPPED_CORE_COUNT, NOC_CORES);
    return 1;
  }
  printf("\n\nInterNoC execution finished...");
  return 0;
}